//prints vDOM tree to compare with DOM
//tabs is used as helper to print the DOM in a readable format
const printDOMTree = (node, tabs = "") => {
    if (node.children === undefined) {
        return tabs + node[0].tag
    } else {
        prettyPrint = ""
        node.children.forEach(node => {
            prettyPrint += tabs + node.tag + "\n" + printDOMTree(node.children, tabs + "\t") + "\n";
        })
        return prettyPrint;
    }
}

function updateDOMProperties(node, prevVNode, nextVNode) {
    //if this is a text node, update the text value
    if (prevVNode.tag == "TEXT_ELEMENT" && nextVNode.tag == "TEXT_ELEMENT") {
        node.nodeValue = nextVNode.nodeValue;
    }
    //add/remove attributes, event listeners 
    //remove attributes
    Object.keys(prevVNode.attributes || [])
                .forEach((key, _) => {
                    node.removeAttribute(key);
        });

    //remove old event listeners 
    Object.keys(prevVNode || [])
                .filter(isEvent)
                .forEach(key => {
                    node.removeEventListener(key, prevVNode[key])
        });       

    //add attributes
    Object.keys(nextVNode.attributes || [])
            .forEach((key, _) => {
                const val = nextVNode.attributes[key];
                //need to handle class differently 
                key === 'class' ? node.className = val : node[key] = val;
        });

    //add event listeners
    Object.keys(nextVNode.events || [])
            .forEach((key, _) => {
            node.addEventListener(key, nextVNode.events[key]);
        });
}
 
 
const isEvent = key => key.startsWith("on");
const isDOM = node => node.nodeType !== Node.TEXT_NODE;
//instantiate a virtual DOM node to an actual DOM node
const instantiate = (vNode) => {
    if (!vNode.tag) {
        //if no tag, then this is already a rendered DOM node,
        if (vNode.node) {
            return vNode.node
        } 
        return vNode;
    } else {
        const domNode = vNode.tag !== "TEXT_ELEMENT" ? document.createElement(vNode.tag) : document.createTextNode(vNode.nodeValue);
        updateDOMProperties(domNode, normalize(null), vNode);
        //create children
        const childrenV = vNode.children || [];
        const childrenDOM = childrenV.map(instantiate);
        childrenDOM.forEach(child => {
            domNode.appendChild(child);
        });
        return domNode;
    }
}


//Tags
const APPEND = 1;
const DELETE = 2;
const REPLACE= 3;
const UPDATE = 4;

// function performUnitOfWork(unitOfWork) {
//     //do stuff

//     return unit ;
// }

// function workLoop(nextUnitOfWork) {
//     while (nextUnitOfWork) {
//         nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
//     }
// }

//queue to manage all updates to the DOM
//List of {op: <OP>, details: {}}
const updateQueue = [];

//used to update DOM operations from the queue
const performWork = () => {
    var node = null;
    while (updateQueue.length > 0) {
        //removes and returns item at index 0
        //TODO: is there a more optimized way of doing this
        const item = updateQueue.shift();
        switch (item.op) {
            case APPEND:
                parent = item.details.parent;
                child = item.details.node;
                updateDOMProperties(child, normalize(null), item.details.node);
                if (parent) {
                    parent.appendChild(child);
                }
                break;
            case REPLACE:
                dom = item.details.dom
                prev = item.details.previous;
                next = instantiate(item.details.node);
                //update properties
                updateDOMProperties(dom, prev, next);
                dom.replaceWith(next);
                node = next;
                break;
            case DELETE:
                parent = item.details.parent;
                toRemove = item.details.node;
                parent.removeChild(toRemove);
                break;
            case UPDATE:
                dom = item.details.dom;
                prev = item.details.prev;
                newNode = item.details.new;
                updateDOMProperties(dom, prev, newNode);
        }
    }
    return node;
}

//used to normalize vDOM nodes to prevent consantly checking if nodes are undefined before accessing properties
const normalize = (vNode) => {
    if (!vNode) {
        return {tag: "", children: [], events: {}, attributes: {}};
    } 
    return vNode;
}
 
//main render method for reconciliation
//newVNode: is new vDOM node to be rendered, 
//prevVNode: is old vDOM node that was previously rendered
//nodeDOM: is the corresponding node in the DOM
const renderVDOM = (newVNode, prevVNode, nodeDOM) => {
    const sameType = prevVNode && newVNode && newVNode.tag === prevVNode.tag;
    prevVNode = normalize(prevVNode);
    newVNode = normalize(newVNode);
    var node = normalize(null);
    //same node, only update properties
    if (sameType) {
        //means we have an element loaded in a list node since list nodes hand over fully rendered DOM nodes
        if (newVNode.tag === undefined) {
            updateQueue.push({op: REPLACE, details: {dom: nodeDOM, previous: prevVNode, node: newVNode}});
            node = newVNode;
        } else {
            updateQueue.push({op: UPDATE, details: {dom: nodeDOM, prev: prevVNode, new: newVNode}});  
            //render children
            if (newVNode.children) {
                const count = Math.max(newVNode.children.length, prevVNode.children.length);
                const domChildren = nodeDOM ? nodeDOM.childNodes : [];
                for (let i = 0; i < count; i++) {
                    newChild = newVNode.children[i];
                    prev = prevVNode.children[i]; 
                    domChild = domChildren[i]; 
                    child = renderVDOM(newChild, prev, domChild);
                    //only append node if it's new
                    if (child && !prev) {
                        updateQueue.push({op: APPEND, details: {parent: nodeDOM, node: child}});  
                    }
                }
            }
            node = nodeDOM;
        }
    } else if (newVNode.tag == "") {
        //node is no longer present so remove previous present virtual node
        //note if the DOM node is undefined, then that node has already been handled i.e. removed or added in a previous iteration
        if (nodeDOM) {
            updateQueue.push({op: DELETE, details: {parent: nodeDOM.parentNode, node: nodeDOM}});
            //Note we want to to return here (i.e. not perform any work yet) to avoid removing DOM nodes before 
            //we have processed all of the children (to avoid indexing issues at line 168 causing us to skip nodes). This means we defer the 
            //`performWork` operation to be called by the parent. Note there is no scenario where we would encounter
            //an empty newVNode that reaches this block without being called by a parent.
            return node;
        }
    } else if (prevVNode.tag == "") {
        //Double check: is this bit already implemented?
        //-----------
        //uses a similar heuristic to the React diffing algorithm
        //if the nodes are dif create new node
        //-----------
        //create new node
        node = instantiate(newVNode);
        if (nodeDOM) {
            //return child, parent will handle the add to the queue
            return node;
        }
        updateQueue.push({op: APPEND, details: {parent: null, node: node}}); 
        
    } else {
        //node has changed, so replace
        updateQueue.push({op: REPLACE, details: {dom: nodeDOM, previous: prevVNode, node: newVNode}});
    }

    //Done diffing so we can now render the updates
    const res = performWork();
    //one edge cases that arises is when we attempt to replace the entire DOM tree (i.e. on first iteration) - we push to the queue 
    //but never assign node which we initialize to `normalize(null)`. This would result in incorrectly updating the DOM to null so we check
    //for this case here
    if (res && node.tag === "") node = res;
    return node;
}
 
 
 
 //This is the internal representation of a vDOM node in Poseidon that we will then render onto the DOM
 //note we don't use the type and props approach of react because we're going to be creating our virtual DOM representation
 const node = {
     //tag i.e. h1, p etc.
     tag: '',
     children: [],
     //any events it's listening to e.g. onclick, onmousedown etc, maps keys of events to listen to to responses
     events: {},
     //map of attributes to values (e.g. {class: "...", id: "../"})
     attributes: {}
 };
 

 function css(string) {
    const componentStyles = string[0].replace("\n", "");
    res = {}
    //pass optional g flag to return all matches (not just the first one)
    //will match < name { rule: value } > 
    var regex = new RegExp('([\\s\\S]*?){([\\s\\S]*?)}', 'g');
    var arr;
    //loop while we're still matching
    while (true) {
        arr = regex.exec(componentStyles); 
        if (!arr) {
            break;
        }
        const selector = arr[1].trim();
        if (!res[selector]) {
            res[selector] = [];
        }
        //body inside selector, split by semi-colons
        const bodyNoNewLines = arr[2].replace(/(\r\n|\n|\r)/gm, "");
        const body = bodyNoNewLines.split(";");
        for (let rule of body) {
            //TODO: make more efficient
            if (!(rule.trim())) {
                continue;
            }
            const formattedRule = rule.split(":");
            const styleRule = formattedRule[0].trim();
            const val = formattedRule[1].trim();
            res[selector].push({[styleRule] : val}); 
        }
    }
    return res;
 }

 
 //unit of UI
class Component {
    constructor(...args) {
        //initialize stuff
        //vdom from create
        this.vdom = null;
        if (this.init !== undefined) {
            this.init(...args);
        }
        //actual DOM node
        //`this.data` is a reserved property for passing into create to reduce side-effects and allow components to create UI without
        //having to rely on getting the data from elsewhere (can define in it in init of a user-defined component)
        if (this.node === undefined) {
            this.render(this.data);
        }
    }
    
    //bind allows us to bind data to listen to and trigger an action when data changes. Similar to useState in React which 
    //triggers a re-render when data changes
    bind(source, handler) {
        //if no handler passed in, we assume the callback is just a re-render of the UI because of a change in state
        //handler passed in should be a JS callback that takes data and does something (data = new updated data)
        if (handler === undefined) {
            source.addHandler((data) => this.render(data));
        } else {
            source.addHandler(handler);
        }
    }

    //method for adding in-line css styling to components via css template literal, should be overrided in relevant component
    styles() {
        return null;
    }

    //helper method for adding component-defined styles 
    addStyle() {
        //write own css parser
        const style = document.createElement('style');
        const userStyles = this.styles();
        if (userStyles) {
            var text = "";
            Object.keys(userStyles).forEach(selector => {
                text += selector + " { \n";
                userStyles[selector].forEach((item, _)=> {
                    const key = Object.keys(item);
                    const val = item[key];
                    text += key + ":" + val + ";\n";
                })
                text += "}\n\n";
            });
            //create style tag
            const cssNode = document.createElement('style');
            cssNode.type = 'text/css';
            if (css.styleSheet) {
                cssNode.styleSheet.cssText = text;
            } else {
                cssNode.appendChild(document.createTextNode(text));
            }
            document.getElementsByTagName('head')[0].appendChild(cssNode);
        }
    }


    remove() {
        //take down any things necessary from the DOM
    }

    //create allows us to compose our unit of component
    //should be deterministic and have no side-effects (i.e. should be rendered declaratively)
    create(data) {
        //eventually will need to do manipulation to convert template string into this format, but start simple for now
        return null;
    }

    //converts internal representation of vDOM to DOM node 
    //used to render a component again if something changes - ONLY if necessary
    render(data) {
        //not sure what to do with render yet
        const newVdom = this.create(data); 
        this.node = renderVDOM(newVdom, this.vdom, this.node);
        this.addStyle();
        this.vdom= newVdom;
        return this.node;
    }
}
//Listening class is used to connect handlers
//to data/models for evented data stores (like in Torus)
class Listening {
    constructor() {
        this.handlers = new Set();
        //represent the current state of the data
        //used to determine when a change has happened and execute the corresponding handler
        this.state = null;
    }
    //return summary of state
    summarize() {
        return null;
    }

    //used to listen to and execute handlers on listening to events
    fire() {
        this.handlers.forEach(handler => {
            //call handler with new state
            //since we pass in the state, this means we have access directly to an atom's data (aka state) in the handler
            //(including a call to render)
            handler(this.state);
        })
    }

    //called when an atom is taken down to remove all subscribed event handlers
    remove() {
        this.handlers.forEach(handler => {
            //remove handler 
            this.removeHandler(handler)
        })
    }

    addHandler(handler) {
       this.handlers.add(handler);
       handler(this.state);
    }

    removeHandler(handler) {
        this.handlers.delete(handler);
    }
}
 
 
 //atom is smallest unit of data, similar to record in Torus
class Atom extends Listening {
    constructor(object) {
        super();
        super.state = object;
    }

    summarize() {
        return this.state;
    }

    //default comparator should be overrided for custom functionality in atom class
    get comparator() {
        return null;
    }

    //all children of atoms should include a method that returns their type (base implementation provided for general Atom)
    //but should be specific to implementing atom class
    get type() {
        return Atom;
    }
    

    //called to update the state of an atom of data
    //takes in an object of keys to values
    update(object) {
        for (const prop in object){
            this.state[prop] = object[prop];
        }
        //change has been made to data so call handler
        this.fire();

    }

    //used to return a property defined in an atom
    get(key) {
        return this.state[key];
    }

    //convert data to JSON (potentially for persistent store, etc.)
    serialize() {
        return JSON.stringify(this.state); 
    }
 
}
 
//Lists are backed by collection data stores (middle man between database and the UI) to map collections to the UI
class List extends Component {
    //fix constructor with args
    constructor(item, store, remove) {
        //call super method
        super(item, store, remove);
        this._atomClass = store.atomClass;
    }
     
    init(item, store, remove) {
        this.store = store;
        this.remove = remove;
        //domElement is the unit of component that will render each individual element of a list 
        this.domElement = item;
        //backed by Javascript Map since maintains order and implements iterable interface, allowing easy manipulation when looping
        //this items maps atoms as keys to DOM nodes as values. This prevents us having to re-render all DOM list elements, and only
        //re-render the elements that have changed or the ones that need to be added
        this.items = new Map();
        this.nodes = [];
        //will initialize map on first call of itemsChanged() -> binding calls handler the first time
        this.bind(store, () => this.itemsChanged());
    }

    itemsChanged() {
        //loop over store and add new elements
        //TODO: does this work correctly if you CHANGE existing elements, EDIT: it doesn't
        this.store.data.forEach((element) => {
            if (!this.items.has(element)) {
                //pass in the atom to the new initialized component as well as the callback to remove an item from a store
                //so that each component can remove its own atomic data
                const domNode = new this.domElement(element, this.remove);
                //note we pass the DOM nodes of the rendered component so that each defined component (i.e. domElement above) has 
                //a reference to the actual DOM node being displayed on the web page. If we passed in a vDOM node, then 
                //our rendering logic would instantiate a new DOM node and add it to the page but the component 
                //(elemnt of a list) would not have a reference to this DOM node locally and would not be able update 
                //changes (on the web page) reflected to its state (and a goal of Poseidon is that we have self-managing components 
                //so should be able to display changes to changes in atomic data directly within our own component)
                this.items.set(element, domNode.node);
            } 
        })
        //loop over map and remove old elements
        for (let [key, value] of this.items) {
            if (!this.store.has(key)) {
                this.items.delete(key);
            } 
        }
        this.nodes = Array.from(this.items.values()); 
        this.render(this.nodes);
    }

    get type() {
        return this._atomClass;
    }

    create(data) {
        return null;
    }

    summarize() {
        return
    }

}

function ListOf(itemOf) {
    return class extends List {
        constructor(...args) {
            super(itemOf,...args);
        }
    }; 
}

//middle man between database and the UI. Used to store collections and interface with the UI
//similar to Store in Torus and Collections in Backbone
class CollectionStore extends Listening {
    constructor(data, atomClass) {
        //TODO: fix super call
        super();
        this._atomClass = atomClass;
        this.setStore(data); 
    }

    //will typically have a fetch and save method to cache data locally from the database to load the UI and save upon rewrites
    //setStore provides a flexible way to intialize a store with data (either via the constructor or e.g. an internal fetch method)
    setStore(data) {
        //4 possible configurations for initalizing a store with data
        //1. Pass in objects with Atom
        //2. Pass in intialized atoms as an array with no type (inferred)
        //3. 1 but via CollectionStoreOf
        //4. 2 but via CollectionStoreOf
        if (data !== undefined && data !== null && data.length > 0) {
            //assume all data is the same type if no atom class is provided (meaning we can infer it directly, since just list of atoms) 
            if (this._atomClass === undefined) {
                this.data = new Set(data);
                //TODO: is there a better way of doing this?
                this._atomClass = data[0].type;
            } else {
                if (data[0] instanceof Atom) {
                    this.data = new Set(data);
                } else {
                    this.data = new Set(data.map(el => new this._atomClass(el)));
                }
            }       
        } else {
            this.data = new Set();
        } 
    }

    summarize() {
        return JSON.stringify(this.data);
    }

    add(newData) {
        this.data.add(newData);
        if (this._atomClass === undefined) {
            this._atomClass = newData.type;
        }
        //trigger any event handlers that are subscribed to the store for an update
        this.fire();
    }

    has(value) {
        return this.data.has(value);
    }

    remove(oldData) {
        //remove atom from the store
        this.data.delete(oldData);
        //call atom's remove to remove all subscribed event handlers
        oldData.remove();
        //trigger any event handlers that are subscribed to the store for an update
        this.fire();

    }

    //return JSON serialized data sorted by comparator
    serialize() {
        //creates array with spread syntax, then sorts
        //TODO: is there a more efficient way of doing this
        const sorted = [...this.data];
        sorted.sort((a , b) => {
            return a.comparator - b.comparator;
        });
        return JSON.stringify(sorted);
    }

    get atomClass() {
        return this._atomClass;
    }

    //define customer iterator interface so we can loop over stores directly
    //take advantage of the iterator values() returns since data is a Javascript set 
    [Symbol.iterator]() {
        return this.data.values();
    }
}

//Higher order component pattern like in Torus
function CollectionStoreOf(classOf) {
    return class extends CollectionStore {
        constructor(data) {
            super(data, classOf);
        }
    };
}

//helper method to convert passed in paths into executable regex values to match against incoming routes
const getRegexFromRouteString = (route) => {
    let match;
    let paramNames = []
    //construct a new regex match by replacing paramnames as defined in the route e.g. /:user
    //with corresponding regex bits to match any possible values
    route = route.replace(/[:*](\w+)/g, (full, paramName, _) => {
        paramNames.push(paramName);
        //replace any paramname with a regex to match any value (since any value can be passed in as a parameter e.g. any user!)
        //matches any character that is not a /
        return '([^\/]+)'
    });
    //may be the end of the route or may there may be more stuff, so add a regex to capture this
    route += '(?:\/|$)'
    return [new RegExp(route), paramNames];
}


//NOTE: this is a client-side router. This means that when the URL changes, it looks at the client-side
//Javascript code to determine what to render. This means that if you're using any kind of web server
//and serving the static content from there, either you must allow ALL routes or the routes you'd like to 
//define on the client-side on the web server. If you don't do this, nothing will be served once you navigate to a route 
//even if you've specified what to render through Poseidon.
class Router {
    //client-side router, match-based router (i.e. builds a routing table)
    //constructor takes an object which maps names of routes to their corresponding path
    //when passing routes, make sure to pass more general routes later since Poseidon will match them
    //in that order
    constructor() {
        this.routes = new Map();        
        this.options = {
            context: window,
            startListening: true
        }
        this.matchHelper = () => {
            return this.match(window.location.pathname);
        }
        //used to detect when URL changes and execute a handler accordingly
        window.addEventListener('popstate', this.matchHelper); 
    }

    //route-matching algorithm
    //listener method for when the URL or hash changes to map to the new appropriate view
    match(route) {
        //match route against dictionary of defined paths to their relevant attributes
        for (let [path, {pathRoute, handler, params}] of this.routes) {
            const match = pathRoute.exec(route);
            //each route will be associated with a handler
            //this handler will handle all of the rendering associated with a new change
            if (match !== null) {
                //remove the first / from the route
                //loop through values and add each value with its associated parameter
                const routeParams = match.slice(1).
                                    reduce((allParams, value, index) => {
                                            allParams[params[index]] = value;
                                            return allParams;
                                            }, {});
                //split parameters using the ?varName=varVal 
                this.currentPath = path;
                handler(route, routeParams);
            }

        }
    }

    navigate(path, {replace = false} = {}) {
        if (window.location.pathname != path) {
            if (replace) {
                this.options.context.history.replaceState(null, document.title, path);
            } else {
                //add entry to browser's session history stack (will set the location's hash)
                this.options.context.history.pushState(null, document.title, path);
            }
            this.match(path);
        }
    }

    //used to map paths to handler functions which will get executed when navigated to
    on(...pageRoutes) {
        for (const {route, handler} of pageRoutes) {
            if (Array.isArray(route)) {
                for (const path of route) {
                    const [regPath, params] = getRegexFromRouteString(path);
                    this.routes.set(path, {pathRoute: regPath, handler: handler, params: params});
                }
            } else {
                const [regPath, params] = getRegexFromRouteString(route);
                this.routes.set(route, {pathRoute: regPath, handler: handler, params: params})
            }
        }
        //route the current url
        this.match(window.location.pathname);
    } 

}

//jsx like parser written in Javascript for Poseidon's vdom

//TODO:
//Interpolate all template literals with string values and store them in a map
//Then build node out, when a string is encountered, go retrieve that value as the tree is being constructed
//makes the algorithm more efficient since only one traversal is done


//Reader class to abstract lexing and scanning of a vdom template string
class Reader {
    constructor(string) {
        this.string = string;
        this.index = 0;
        this.length = string.length;
        //set of special characters to return when getNextWord is called
        this.specialCharacters = new Set([' ', '=', '<', '>']);
    }

    peek() {
        if (this.index < this.length - 1) {
            return this.string[this.index + 1];
        }
        return null;
    }

    //gets the next word, keeps moving forward until until it encounters one of the special tags or a closing '/>'
    getNextWord() {
        var currIndex = this.index;
        var finalIndex = currIndex;
        var quoteCount = 0;
        //keep looping while we don't encounter a special character of if we're inside a quote
        while ((this.index < this.length) && (!this.specialCharacters.has(this.currentChar) || quoteCount === 1)) {
            //if we have quotes, skip them
            //TODO: add more robust type checking we have the same type of quote
            if (this.currentChar === '"' || this.currentChar === "'") {
                //adjust starting point of returned work if we encounter an opening quote
                if (quoteCount === 0) { 
                    quoteCount += 1;
                    currIndex = this.index + 1;
                } else if (quoteCount === 1) {
                    finalIndex = this.index - 1;
                    quoteCount += 1;
                }  
            } else if (this.currentChar === '/') {
                //handle special case where next word might be adjacent to a /> tag so return the word before
                //this tag
                //otherwise, since this is
                if (this.peek() === '>') break
            } else {
                finalIndex = this.index;
            } 
            this.consume();
        }
        if (quoteCount == 1) { 
            throw 'Error parsing quotes as values!';
        }

        //skip any spaces for future
        this.skipSpaces();
        return this.string.substring(currIndex, finalIndex + 1);
    }

    get currentChar() {
        return this.string[this.index];
    }

    //skip all white spaces and new line characters
    skipSpaces() {
        while (this.currentChar === " " || this.currentChar === '\n') {
            this.consume();
        }
    }

    consume() {
        return this.string[this.index++];
    }

    //combination of consume and skipping white space since this pattern crops up frequently
    skipToNextChar() {
        this.consume();
        this.skipSpaces();
    }

    //helper method to keep moving pointer until the current char is the provided one
    getUntilChar(char) {
        const currIndex = this.index;
        var finalIndex = currIndex;
        while (this.currentChar != char && this.index < this.length) {
            this.consume();
            finalIndex = this.index;
        }
        return this.string.substring(currIndex, finalIndex);
    }

    //keep moving pointer forward until AFTER we encounter a char (i.e pointer now points to character after matching provided)
    skipPastChar(char) {
        var text = this.getUntilChar(char);
        text += this.consume();
        return text;
    }
}


//recursively loop checking children
const parseChildren = (closingTag, reader, values) => {
    try {
        let children = [];
        //check in the scenario where we have an empty HTML node with no children
        if (foundClosingTag(closingTag, reader)) {
            return children;
        }
        var nextChild = parseTag(reader, values);
        while (nextChild !== CLOSED_TAG) {
            //only append child if it's not null or undefined
            if (nextChild) {
                //check if this is the result of returning an array (e.g. if a map operation is called), in which case, we set children 
                //to the result otherwise introducing nesting which will cause issues when trying to render
                if (Array.isArray(nextChild)) children = nextChild
                else children.push(nextChild);
            }
            if (foundClosingTag(closingTag, reader)) break;
            nextChild = parseTag(reader, values);
        }
        return children;
    } catch (e) {
        throw e;
    }
}


//helper method to check if we've encountered the closing tag of a node
//return true if we have and false if we have not encountered the closing tag
const foundClosingTag = (closingTag, reader) => {
    if (reader.currentChar === '<' && reader.peek() === '/') {
        //if we encounter closing tag i.e. '</' then end parsing of this tag
        reader.skipPastChar('/');
        const nextTag = reader.getNextWord();
        reader.skipPastChar('>');
        if (nextTag !== closingTag) throw 'Error parsing the body of an HTML node!'
        return true;
    }
    return false
}

//method which parses JS expressions in our template literal vdom string
//takes a reader, list of values from the template string, and an optional attribute variable that indicates whether this expression
//should return a node (i.e. call parseTag) or return a value associated with some key (e.g an attribute)
const parseJSExpr = (reader, values, attribute) => {
    //return the Javascript expression
    //What's a cleaner way of doing this
    var val = values.shift();
    //if the value returns null we don't want to render anything
    if (val) {
        //if this is a JSX expression associated with some key, return the value obtained directly instead of parsing it as a HTML node
        if (attribute) {
            reader.skipSpaces();
            //if the val either a function or an object which was generated
            //by a nested vdom template literal, we return it directly
            //otherwise, we cast any other non-string primitives if the returned value is not already a string to prevent unnecessary computations
            if (typeof val === 'function' || typeof val === 'object') return val;
            else if (typeof val !== 'string') val = String(val);
            return val;
        }
        //Not DRY, but the alternative is some hard to understand gymnastics
        if (typeof val === 'object' || typeof val === 'function') {
            reader.skipSpaces();
            //if an anonymous function is passed in as a body execute it
            if (typeof val === 'function') {
                return val();
            } else {
                return val;
            }
        } else if (typeof val !== 'string') val = String(val); 

        //notice this set-up nicely allows for nested vdom expressions (e.g. we can return another vdom template literal based on some
        //Javascript expression within another vdom)
        const readerNewExpression = new Reader(val);
        return parseTag(readerNewExpression, values); 
    } else {
        return null;
    }
}


//parse a complete HTML node tag 
const parseTag = (reader, values) => {
    //if the current char is not a < tag, then either we've finished parsing valid tags or this is a text node
    if (reader.currentChar !== '<') {
        const word = reader.getUntilChar('<');
        //we've reached the end of parsing
        if (!word) return null;
        //otherwise, we've found a text node!
        return {tag: "TEXT_ELEMENT", nodeValue: word};
    } else if (reader.peek() === '/') {
        //just encountered a '</' indicating a closing tag so return the constant to let the caller method know 
        //note we return this constant (instead of null) to differentiate from null nodes which may not necessarily be the last nodes 
        //left to parse
        return CLOSED_TAG;
    }  
    //skip < tag
    reader.consume();
    const name = reader.getNextWord();
    //check if this is a placeholder for a JS expression
    if (name === VDOM_PLACEHOLDER) {
        //skip < tag
        reader.consume();
        return parseJSExpr(reader, values, false);
    }        
    const node = {
        tag: name,
        children: [], 
        attributes: {},
        events: {}
    }
    //boolean variable to handle special self-closing HTML nodes like <img />
    var specialChar = false;
    //Match key-value pairs in initial node definition (i.e. from first < to first > tag, recall closing node tag is </)
    while (reader.currentChar !== '>') {
        const key = reader.getNextWord();
        //handle special self-closing tags like <br/> and <img />
        if (key === '/' && reader.peek() === '>') {
            reader.consume();
            specialChar = true;
            break;
        }
        //key on its own is still valid, so check if we need to map to a specific value
        if (reader.currentChar !== '=') {
            node.attributes[key] = true;
            continue;
        }
        //skip equal sign
        reader.skipToNextChar();
        //get value associated with this key 
        let value = reader.getNextWord();
        //getNextWord stops at some special characters, one of which is < which is the start of the VDOM_JSX_Node
        //so check if this is a placeholder before parsing the JS expression to get the value associated with this key
        if (value === '<') {
            //skip < tag and check if this is a valid placeholder
            reader.consume();
            if (reader.getNextWord() === VDOM_PLACEHOLDER) value = parseJSExpr(reader, values, true);
            else throw "Error trying to parse the key-value pairs of a node, unexpected < found!"
            //skip closing tag
            reader.consume();
        }
        //if the key starts with an on, this is an event, so we should save it accordingly
        if (key.startsWith("on")) {
            //note keys of events in JS don't include on, so we ignore this part of the string when assigning it
            node.events[key.substring(2)] = value;
        } else {
            //otherwise, this is an attribute so add it there
            node.attributes[key] = value;
        }
    }
    //skip closing > of node definition and any spaces/new lines
    reader.skipToNextChar();
    //match actual body of the node
    if (!specialChar) node.children = parseChildren(name, reader, values);
    //return JSON-formatted vdom node
    return node;
}

//Regular expression to match all expressions (or JS codes) inside a dom template string
//This lazily matches (lazily meaning as few as possible) any '${}' characters within a template string
const VDOM_EXPRESSIONS = new RegExp('\${.*?}', 'g');
//use the current Date or time to ensure we have a unique placeholder in our template strings which will replace
//all Javascript expressions (i.e. ${}) that need to be executed which we refer to during the parsing phase
const VDOM_PLACEHOLDER = `__vdomPlaceholder${Date.now()}`;
//we wrap the placeholder in opening and closing tags to avoid checking extra edge cases in our parser which would introduce
//extra, unneccessary computations
const VDOM_JSX_NODE = "<" + VDOM_PLACEHOLDER + ">"
//constant used when parsing children nodes to check whether we've finished parsing all child nodes and have found the closing parent
const CLOSED_TAG = "</";

//take advantage of Javascript template literals which gives us a string and a list of interpolated values
const html = (templates, ...values) => {
    //create string and interpolate all of the ${} expressions with our constructed placeholder node 
    const vdomString = templates.join(VDOM_JSX_NODE, values);
    //HTML parsing
    const reader = new Reader(vdomString);
    try {
        reader.skipSpaces();
        const node = parseTag(reader, values);
        return node;
    } catch (e) {
        console.error(e);
    }
}
